Anotações TOUR OF HEROES
0.  Criação do projeto: https://angular.io/tutorial/toh-pt0
1.  O editor do herói: https://angular.io/tutorial/toh-pt1
    1.1.  Uso de diretivas. Two way data bind: [(ngModel)]. Para usar esta diretiva, são necessários alguns passos
        1.1.1.  Fazer a importação do FormsModue: import { FormsModule } from '@angular/forms'; // <-- NgModel lives here
        1.1.2.  Criar a propriedade, dentro da classe do componente que receberá o valor da diretiva [(ngModel)]
        1.1.3.  Colocar a diretiva no html, apontando p/ a propriedade que eu quero atualizar: [(ngModel)]="hero.name"
    1.2.  DIRETIVAS: As diretivas são marcadores em um elemento DOM (como um atributo) que informam ao Angular para anexar um comportamento 
          especificado a um elemento existente.
          Algumas diretivas podem mudar completamente a estrutura da saída do template do componente. Essas diretivas podem alterar o 
          layout do DOM adicionando e removendo elementos DOM de visualização.
        1.2.1.  Podemos classificar essas diretivas em estruturais. 
                Usadas com *
                *NgIf
                *NgFor
                *NgSwitch, NgSwitchWhen, NgSwitchDefault
        1.2.2.  Outras diretivas podem simplesmente alterar a aparência dos itens gerados pelo modelo. 
                Vamos chamar essas diretivas de atributo:
                Usadas dentro de []
                [NgClass]
                [NgStyle]
                [NgControlName]
                [NgModel]
        1.2.3.  https://angular.io/guide/built-in-directives
                The different types of Angular directives are as follows:
                Components—directives with a template. This type of directive is the most common directive type.
                Attribute directives—directives that change the appearance or behavior of an element, component, or another directive.
                Structural directives—directives that change the DOM layout by adding and removing DOM elements.        
2.  Exbindo uma lista: https://angular.io/tutorial/toh-pt2
    2.1.  Event binding
        2.1.1.  <li *ngFor="let hero of heroes" (click)="onSelect(hero)">
                This is an example of Angular's event binding syntax.
                The parentheses around click tell Angular to listen for the <li> element's click event. When the user clicks 
                in the <li>, Angular executes the onSelect(hero) expression.
    2.2.  Class binding. Angular permite que você adicione ou remova uma classe CSS de forma condicional.
          Basta adicionar: [class.some-css-class]="some-condition"
        2.1.1.  [class.selected]="hero === selectedHero"
3.  Criando um novo componente (feature component): https://angular.io/tutorial/toh-pt3
    3.1.  What changed?
          As before, whenever a user clicks on a hero name, the hero detail appears below the hero list. 
          Now the HeroDetailComponent is presenting those details instead of the HeroesComponent.
          Refactoring the original HeroesComponent into two components yields benefits, both now and in the future:
        3.1.1.  You reduced the HeroesComponent responsibilities.
        3.1.2.  You can evolve the HeroDetailComponent into a rich hero editor without touching the parent HeroesComponent.
        3.1.3.  You can evolve the HeroesComponent without touching the hero detail view.
        3.1.4.  You can re-use the HeroDetailComponent in the template of some future component.
    3.2.  @Input: A propriedade do componente hero precisa ser @Input() pois o componente externo HeroesComponent faz o bind 
          através do comando: <app-hero-detail [hero]="selectedHero"></app-hero-detail>
        3.2.1.  [hero]="selectedHero" is an Angular property binding.
4.  Adicionando um serviço. Como um componente NÃO DEVE buscar/salvar dados, deve-se ser usado um SERVICE. Os serviços são ótimos
    para compartilhar informação através das classes que "não se conhecem". Para isso usamos a injeção.
    O decorador @Injectable marca a classe como sistema de injeção de dependências e permite que a classe receba metadados
    Outra vantagem dos serviços, é que você pode alterar a origem dos dados, sem se preocupar com os componentes
    4.1.  Uma vez criado o serviço, através do CLI (ng g s hero) faço a criação do método desejado
        4.1.1.  É importante que o meu serviço tenha o decorador @Injectable e o provider
                Ex.:
                @Injectable({
                  providedIn: 'root'
                })
    4.2.  No componente que eu quero fazer a injeção do serviço, devo fazer:
        4.2.1.  A importação do serviço: import { HeroService } from '../hero.service';
        4.2.2.  A injeção do serviço no construtor: constructor(private heroService: HeroService) {}
        4.2.3.  Criar um método para chamar o método criado no serviço
        4.2.4.  Colocar a chamada do método dentro do ngOnInit()
    4.3.  OBSERVABLE DATA: Como iremos consumir dados de um servidor remoto, temos que trabalhar com operações assíncronas e a forma
          que trabalhamos com este tipo de transação assíncrona é com OBSERVABLES e protocolos HTTP.
          Observable é uma das classes mais importantes da biblioteca RxJS
        4.3.1.  No hero.service.ts, fazer a importação: import { Observable, of } from 'rxjs';
        4.3.2.  No método preciso alterar o retorno para: getHeroes(): Observable<Hero[]> {}
        4.3.3.  Em seguida, preciso usar o SUBSCRIBE no método que está chamado o método do serviço
    4.4.  MESSAGES: Adicionando um componente para exibir as mensagens no rodapé da página
        4.4.1.  Criação do componente messages: ng generate component messages
        4.4.2.  Adicionar o componente ao app.component.html: <app-messages></app-messages>
        4.4.3.  Criar o serviço de mensagens: MessageService
            4.4.3.1.  O serviço fica no app: ng generate service message
            4.4.3.2.  Criar propriedade e método
            4.4.3.3.  Injetar o método no HeroService
                4.4.3.3.1.  Em HeroService, importar e injetar o MessageService. Isto cria um "service-in-service"
            4.4.3.4.  Enviar uma mensagem pelo HeroService
                4.4.3.4.1.  Alterar o método para enviar uma mensagem quando os heróis forem recuperados, adicionando a 
                            chamada do serviço:   this.messageService.add('HeroService: fetched heroes');            
            4.4.3.5.  Exibir mensagem recebida do HeroService
                4.4.3.5.1.  Importar o MessageService no componente messages.component. Isto vai permitir ao componente
                            mostrar todas as mensagens inclusive as geradas pelo HeroService
                4.4.3.5.2.  Injetar como público dentro do construtor. Isto porque faremos o bind em um template
                            The messageService property must be public because you're going to bind to it in the template.
                            Angular only binds to public component properties.
            4.4.3.6.  Fazer o bind no MessageService. Preparar o HTML para exibir mensagens e limpá-las, quando necessário
5.  Adicionando navegação (Routing)
    5.1.  Criando o arquivo de roteamento. Normalmente, quando eu crio um projeto em angular eu já crio o arquivo de roteamento
          porem, caso eu preciso adicionar depois, preciso executar o comando: 
          ng generate module app-routing --flat --module=app
          --flat puts the file in src/app instead of its own folder.
          --module=app tells the CLI to register it in the imports array of the AppModule.
    5.2.  ROUTES: 
          O PATH é onde colocamos o texto que será adicionado a URL.
          O COMPONENT é o componente que a rota deverá carregar
    5.3.  No app.component.html, adicionar o <router-outlet> para que o angular carregue as views roteadas
    5.4.  Adicionando um link de navegação. Basta colocar um <nav> <a routerLink="/heroes">, ou seja, o link que aponta para minha rota
    5.5.  Adicionando uma rota padrão: { path: '', redirectTo: '/dashboard', pathMatch: 'full' }. Ou seja, quando o site for carregado,
          que bata com o pathMatch, o link carregado será o do redirectTo
    5.6.  Adicionado um path parametrizado: { path: 'detail/:id', component: HeroDetailComponent }
          Os : no path indicam que o :id é um placeholder para um id
          5.6.1.  INTERPOLATION BINDING: Para chamar um path parametrizado, eu preciso fazer a interpolação bind routerLink="detail/{{hero.id}}". Conforme exemplo:
                  Ex.: 
                  <a *ngFor="let hero of heroes"
                      routerLink="/detail/{{hero.id}}">
                      {{hero.name}}
                  </a>
    5.7.  Transformando meu componente (HeroDetailComponent) em roteável. Este componente precisa extrair o parâmetro id da rota
        5.7.1.  Em hero-detail.component.ts, fazer a importação de ActivatedRoute e Location
            5.7.1.1.  ActivatedRoute, mantem a informação da rota da instancia de HeroDetailComponent. É usado pois este componente
                      está interessado em extrair o id da URL e injetar no construtor
            5.7.1.2.  Location, é um serviço do Angular para interagir com o navegador e será usado para fazer o botão voltar
        5.7.2.  Extraindo o id da rota parametrizavel
            5.7.2.1.  Dentro do hero-detail-component.ts, criar um método (para ser chamado no ngOnInit()), que extraí o id da rota.
                      Ex.:
                      ngOnInit(): void {
                            this.getHero();
                      }

                      getHero(): void {
                        const id = +this.route.snapshot.paramMap.get('id');
                        this.heroService.getHero(id)
                            .subscribe(hero => this.hero = hero);
                      } 
                5.7.2.1.1.  route.snapshot: é uma imagem estática da informação da rota, imediatamente a criação do componente
                5.7.2.1.2.  paramMap: é um dicionário dos parâmetros da rota, ou seja, identifica os parâmetros na URL e usando o .get(id), pego o parametro desejado
                5.7.2.1.3.  +this: Como as rotas são SEMPRE strings, o JavaScript + operador, convert string em número
            5.7.2.2.  Dentro do hero.service.ts, criar o método getHero()
                      Ex.:
                      getHero(id: number): Observable<Hero> {
                        const hero = HEROES.find(h => h.id === id) as Hero;
                        this.messageService.add(`HeroService: fetched hero id=${id}`);
                        return of(hero);
                      }
                5.7.2.2.1.  O método é Observable, pois é assíncrono
                5.7.2.2.2.  HEROES, é um array e por isso posso usar o .find() que é um predicate e retorna a primeira ocorrencia do array
                            conforme definido no arrow function (h => h.id === id) como um objeto de Hero (as Hero)
            5.7.2.3.  Para criar um botão e retornar a página anterior, é possível criar um método para simular o botão voltar
                      Ex.: 
                        goBack(): void {
                            this.location.back();
                        }    